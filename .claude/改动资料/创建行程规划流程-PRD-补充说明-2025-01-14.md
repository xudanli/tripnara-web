# 创建行程规划流程 PRD - 补充说明

**补充日期**：2025-01-14  
**基于评审文档**：`创建行程规划流程-PRD-前端角色评审-2025-01-14.md`

本文档根据前端角色的评审意见，补充 PRD 文档中缺失的技术细节和实现说明。

---

## 一、类型定义的完整代码

### 1.1 类型定义文件位置

**文件路径**：`src/types/clarification.ts`（新建）

### 1.2 完整类型定义代码

```typescript
/**
 * 澄清问题类型枚举
 */
export type ClarificationQuestionType = 
  | 'text'           // 文本输入
  | 'single_choice'  // 单选
  | 'multi_choice'   // 多选
  | 'date'           // 日期选择
  | 'number';        // 数字输入

/**
 * 验证规则接口
 */
export interface ClarificationQuestionValidation {
  min?: number;        // 最小值（用于 number 和 date，date 使用时间戳）
  max?: number;        // 最大值（用于 number 和 date，date 使用时间戳）
  pattern?: string;    // 正则表达式（用于 text）
}

/**
 * 澄清问题数据结构
 */
export interface ClarificationQuestion {
  id: string;                                    // 问题 ID（唯一标识）
  question: string;                              // 问题文本（用户看到的问题）
  type: ClarificationQuestionType;               // 问题类型
  options?: string[];                            // 选项列表（用于 single_choice 和 multi_choice）
  required: boolean;                             // 是否必填
  placeholder?: string;                          // 占位符（用于 text 和 number）
  hint?: string;                                 // 提示文本（帮助用户理解问题）
  default?: string | string[];                   // 默认值
  validation?: ClarificationQuestionValidation;  // 验证规则（可选）
}

/**
 * 澄清问题回答
 */
export interface ClarificationAnswer {
  questionId: string;                            // 问题 ID（关联 ClarificationQuestion.id）
  value: string | string[] | number | null;      // 回答值
}
```

### 1.3 API 接口类型扩展

**文件路径**：`src/api/agent.ts`

**需要在 `RouteAndRunResponse` 的 `result.payload` 中扩展**：

```typescript
// 需要在 src/api/agent.ts 中导入
import type { ClarificationQuestion } from '@/types/clarification';

// 扩展 RouteAndRunResponse.result.payload
export interface RouteAndRunResponse {
  // ... 现有字段
  result: {
    status: ResultStatus;
    answer_text: string;
    payload?: {
      // ... 现有字段
      clarificationMessage?: string;              // 向后兼容：简单字符串（Markdown 格式）
      clarificationQuestions?: ClarificationQuestion[]; // 新增：结构化问题数组
      // ... 其他字段
    };
  };
  // ... 其他字段
}
```

---

## 二、API 接口的完整说明

### 2.1 API 响应示例

#### **场景 1：需要澄清问题（NEED_MORE_INFO）**

```typescript
{
  request_id: "req-1234567890-abc123",
  route: {
    route: "SYSTEM2_REASONING",
    confidence: 0.9,
    // ... 其他字段
  },
  result: {
    status: "NEED_MORE_INFO",
    answer_text: "为了更准确地规划您的行程，请回答以下问题：",
    payload: {
      clarificationQuestions: [
        {
          id: "question-1",
          question: "请选择您的出行日期",
          type: "date",
          required: true,
          hint: "建议选择 1 个月后的日期，以便提前预订",
          validation: {
            min: new Date().getTime() + 24 * 60 * 60 * 1000, // 明天（时间戳）
            max: new Date().getTime() + 365 * 24 * 60 * 60 * 1000 * 2, // 2年后（时间戳）
          }
        },
        {
          id: "question-2",
          question: "同行人数",
          type: "single_choice",
          required: true,
          options: ["1人", "2人", "3-4人", "5人以上"],
          hint: "这将影响住宿和交通安排"
        },
        {
          id: "question-3",
          question: "您的主要兴趣（可多选）",
          type: "multi_choice",
          required: false,
          options: ["极光", "冰川", "温泉", "文化", "美食", "户外运动"],
          hint: "帮助我们为您推荐合适的景点和活动"
        }
      ]
    }
  },
  explain: {
    decision_log: []
  },
  observability: {
    latency_ms: 1500,
    // ... 其他字段
  }
}
```

#### **场景 2：向后兼容（clarificationMessage）**

```typescript
{
  request_id: "req-1234567890-abc123",
  route: {
    route: "SYSTEM2_REASONING",
    // ... 其他字段
  },
  result: {
    status: "NEED_MORE_INFO",
    answer_text: "为了更准确地规划您的行程，请回答以下问题：",
    payload: {
      clarificationMessage: "请提供以下信息：\n1. 出行日期\n2. 同行人数\n3. 主要兴趣",
      // 没有 clarificationQuestions 字段
    }
  },
  explain: {
    decision_log: []
  },
  observability: {
    latency_ms: 1500,
    // ... 其他字段
  }
}
```

### 2.2 多轮澄清的 conversation_context 格式

**请求格式**（多轮澄清时）：

```typescript
const request: RouteAndRunRequest = {
  request_id: `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
  user_id: user.id,
  trip_id: null, // 新建行程
  message: formatClarificationAnswers(answers), // 格式化后的回答
  conversation_context: {
    recent_messages: [
      originalMessage,              // 用户的原始需求
      formatClarificationAnswers(answers) // 澄清问题的回答（格式化后的文本）
    ],
    locale: 'zh-CN',
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
  },
  options: {
    max_steps: 50,
  }
};
```

**格式化回答的函数**（示例）：

```typescript
function formatClarificationAnswers(
  questions: ClarificationQuestion[],
  answers: ClarificationAnswer[]
): string {
  const answerTexts: string[] = [];
  
  answers.forEach(answer => {
    const question = questions.find(q => q.id === answer.questionId);
    if (!question) return;
    
    let answerText = '';
    if (question.type === 'multi_choice' && Array.isArray(answer.value)) {
      answerText = answer.value.join('、');
    } else {
      answerText = String(answer.value);
    }
    
    answerTexts.push(`${question.question}：${answerText}`);
  });
  
  return answerTexts.join('\n');
}
```

**轮数限制**：

- 前端记录澄清轮数：使用 `useState` 记录 `clarificationRound`
- 超过 5 轮后，显示提示："信息不足，建议使用结构化表单创建行程"
- 提供"切换到表单模式"选项（跳转到 `form` tab）

---

## 三、组件实现的详细说明

### 3.1 ClarificationQuestionCard 组件

**文件路径**：`src/components/trips/ClarificationQuestionCard.tsx`（新建）

**完整的 Props 类型定义**：

```typescript
import type { ClarificationQuestion, ClarificationAnswer } from '@/types/clarification';

export interface ClarificationQuestionCardProps {
  question: ClarificationQuestion;
  value: string | string[] | number | null;
  onChange: (value: string | string[] | number | null) => void;
  error?: string;           // 验证错误信息
  disabled?: boolean;       // 是否禁用
  className?: string;       // 自定义样式类名
}
```

**组件实现要点**：

1. **输入组件的选择标准**：
   - `text` 类型：使用 `Textarea`（如果问题文本长度 > 50 字符）或 `Input`
   - `single_choice` 类型：选项数量 <= 4 时使用 `RadioGroup`，否则使用 `Select`
   - `multi_choice` 类型：使用 `Checkbox` 组，垂直堆叠（`space-y-2`）
   - `date` 类型：使用 `Input type="date"`（项目中没有独立的 DatePicker 组件）
   - `number` 类型：使用 `Input type="number"`

2. **日期选择器说明**：
   - 项目中有 `Calendar` 组件（`src/components/ui/calendar.tsx`），但没有独立的 DatePicker 组件
   - 使用 `Input type="date"` 是更简单的方案，符合现有代码风格（参考 `src/pages/trips/optimize.tsx`）
   - 如果未来需要更复杂的日期选择（如日期范围），可以基于 `Popover + Calendar` 实现

3. **多选组件的布局**：
   - 垂直堆叠（`space-y-2`）
   - 每个选项一行：`<div className="flex items-center space-x-2">`

4. **错误提示的样式**：
   - 位置：输入框下方
   - 样式：`text-sm text-red-500 mt-1`
   - 使用纯文本，不使用 `Alert` 组件（避免视觉噪音）

### 3.2 ClarificationQuestionsPanel 组件

**文件路径**：`src/components/trips/ClarificationQuestionsPanel.tsx`（新建）

**完整的 Props 类型定义**：

```typescript
import type { ClarificationQuestion, ClarificationAnswer } from '@/types/clarification';

export interface ClarificationQuestionsPanelProps {
  questions: ClarificationQuestion[];
  answers: ClarificationAnswer[];
  onAnswerChange: (answers: ClarificationAnswer[]) => void;
  onSubmit: () => void;
  onCancel?: () => void;
  disabled?: boolean;
  className?: string;
}
```

**组件实现要点**：

1. **整体布局**：
   - 使用 `Card` 组件
   - 颜色：`border-yellow-200 bg-yellow-50/30`（需要确认是否符合设计系统 token）
   - 如果没有对应的设计系统 token，使用自定义颜色（需要说明理由）

2. **验证逻辑**：
   - 提交前验证所有必填问题
   - 验证格式（如果有 validation 规则）
   - 显示错误提示

3. **向后兼容处理**：
   - 如果后端返回 `clarificationMessage`，解析为文本类型问题
   - 实现解析函数（参考 0.10.7 节）

---

## 四、状态管理的实现说明

### 4.1 状态管理结构

**在 `src/pages/trips/new.tsx` 中的状态管理**：

```typescript
// 自然语言输入
const [nlText, setNlText] = useState<string>('');
const [loading, setLoading] = useState<boolean>(false);
const [error, setError] = useState<string | null>(null);

// 澄清问题状态
const [clarificationRound, setClarificationRound] = useState<number>(0);
const [clarificationQuestions, setClarificationQuestions] = useState<ClarificationQuestion[]>([]);
const [clarificationAnswers, setClarificationAnswers] = useState<Record<string, ClarificationAnswer>>({});
const [needsClarification, setNeedsClarification] = useState<boolean>(false);

// UI 状态
const [uiStatus, setUiStatus] = useState<UIStatus>('done');
const [orchestrationStep, setOrchestrationStep] = useState<OrchestrationStep | null>(null);
```

### 4.2 状态转换逻辑

**监听 API 响应并更新状态**：

```typescript
const handleSubmit = async () => {
  setLoading(true);
  setError(null);
  setUiStatus('thinking');
  
  try {
    const request: RouteAndRunRequest = {
      request_id: `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      user_id: user.id,
      trip_id: null,
      message: nlText,
      conversation_context: {
        recent_messages: [],
      },
      options: {
        max_steps: 50,
      }
    };
    
    const response = await agentApi.routeAndRun(request);
    
    // 更新 UI 状态（根据 route.ui_hint.status）
    if (response.route.ui_hint?.status) {
      setUiStatus(response.route.ui_hint.status);
    }
    
    // 更新 OrchestrationStep（根据 ui_state.phase）
    if (response.ui_state?.phase) {
      setOrchestrationStep(response.ui_state.phase);
    }
    
    // 处理澄清问题
    if (response.result.status === 'NEED_MORE_INFO') {
      const questions = response.result.payload?.clarificationQuestions;
      if (questions && questions.length > 0) {
        setClarificationQuestions(questions);
        setNeedsClarification(true);
        setClarificationRound(prev => prev + 1);
        setUiStatus('awaiting_user_input');
      } else if (response.result.payload?.clarificationMessage) {
        // 向后兼容：解析 clarificationMessage
        const fallbackQuestion = parseClarificationMessage(response.result.payload.clarificationMessage);
        setClarificationQuestions([fallbackQuestion]);
        setNeedsClarification(true);
        setClarificationRound(prev => prev + 1);
        setUiStatus('awaiting_user_input');
      }
    }
    
    // 处理成功响应
    if (response.result.status === 'OK') {
      // 显示行程预览
      setUiStatus('done');
      // ... 处理行程数据
    }
  } catch (error) {
    setError(error.message);
    setUiStatus('failed');
  } finally {
    setLoading(false);
  }
};
```

### 4.3 状态指示器实现

**使用现有的 StatusIndicator 组件**（参考 `src/components/agent/AgentChat.tsx`）：

```typescript
import { StatusIndicator } from '@/components/agent/AgentChat'; // 如果导出，否则复制实现

// 在组件中使用
<StatusIndicator status={uiStatus} />
```

**状态映射**（根据 `OrchestrationStep` 更新 `UIStatus`）：

- 如果 `response.ui_state?.ui_status` 存在，直接使用
- 否则，根据 `response.ui_state?.phase` 映射到 `UIStatus`

---

## 五、事件流处理的说明

### 5.1 当前实现方式

**根据现有代码分析**（`src/components/agent/AgentChat.tsx`）：

- 当前**不支持**事件流（SSE/WebSocket）
- 使用**单次请求-响应**模式（`agentApi.routeAndRun()`）
- **不支持**实时更新状态

### 5.2 实现建议

**Phase 1（MVP）**：
- 使用单次请求-响应模式
- 用户提交请求后，等待完整响应
- 使用 `UIStatus` 显示处理状态（`thinking`、`browsing`、`verifying` 等）

**Phase 2（未来增强）**：
- 如果后端支持事件流（SSE/WebSocket），可以实现实时状态更新
- 实现事件流处理逻辑（参考 `src/services/orchestrator.ts` 的设计）

---

## 六、技术细节澄清

### 6.1 日期选择器组件

**结论**：
- 项目**没有**独立的 `DatePicker` 组件
- 使用 `Input type="date"`（参考 `src/pages/trips/optimize.tsx` 第 287-292 行）
- 如果未来需要更复杂的日期选择，可以基于 `Popover + Calendar` 实现

### 6.2 设计系统 Token

**澄清问题卡片的颜色**：
- 当前 PRD 中使用：`border-yellow-200 bg-yellow-50/30`
- **建议**：需要确认是否符合设计系统 token
- 如果设计系统有 `warning` token，使用 `bg-warning/10 border-warning/20`
- 如果没有，使用自定义颜色（需要说明理由）

### 6.3 服务层封装

**结论**：
- **不需要**额外的服务层封装
- 直接使用 `agentApi.routeAndRun()` 接口
- 错误处理和状态管理在组件层面处理

### 6.4 状态指示器实现

**结论**：
- 使用现有的 `StatusIndicator` 组件实现（`src/components/agent/AgentChat.tsx`）
- 如果组件未导出，可以复制实现到 `src/components/trips/StatusIndicator.tsx`
- **不需要**修改现有的 `StatusIndicator` 组件

---

## 七、实现优先级

### 7.1 Phase 1（MVP）

1. ✅ 类型定义（`src/types/clarification.ts`）
2. ✅ 组件实现（`ClarificationQuestionCard`、`ClarificationQuestionsPanel`）
3. ✅ 集成到创建页面（`src/pages/trips/new.tsx`）
4. ✅ 数据验证逻辑
5. ✅ 向后兼容处理
6. ✅ 状态管理实现

### 7.2 Phase 2（未来增强）

1. 事件流支持（如果后端支持）
2. 更复杂的日期选择器（如果需要）
3. 实时状态更新（如果后端支持）

---

**补充完成日期**：2025-01-14  
**补充人员**：根据前端角色评审意见
