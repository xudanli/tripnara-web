# 对话历史记录 - 前端集成方案

## 当前状态

### ✅ 已实现的功能

1. **会话恢复**（页面加载时）
   - 从 `localStorage` 读取 `sessionId`
   - 调用 `getNLConversation` 恢复消息历史
   - 恢复 `conversationContext` 和 `partialParams`

2. **会话切换**
   - 监听 `nl-conversation-switch` 事件
   - 加载指定会话的消息历史

3. **更新会话上下文**
   - 在收到 AI 回复后，调用 `updateNLConversation` 更新上下文

### ❌ 缺失的功能

1. **消息自动保存**
   - 目前后端应该在 `createFromNL` 中自动保存消息
   - 但前端没有显式保存消息，可能导致数据不一致

2. **问题答案更新**
   - 用户回答问题后，需要更新消息的 `metadata.questionAnswers`

---

## 集成方案

### 方案1：后端自动保存（推荐）

**优点**：
- 前端代码简单
- 数据一致性由后端保证
- 减少前端 API 调用

**实现**：
后端在 `createFromNL` 接口中自动保存：
1. 用户消息（从请求中的 `text`）
2. AI 回复消息（从响应中的 `plannerReply` 和相关字段）

**前端需要做的**：
- ✅ 确保 `sessionId` 正确传递
- ✅ 确保消息格式正确（后端需要知道如何保存）

### 方案2：前端显式保存（备选）

**优点**：
- 前端完全控制消息保存
- 可以立即看到保存结果
- 便于调试

**缺点**：
- 需要额外的 API 调用
- 可能增加延迟

**实现**：
前端在收到 AI 回复后，显式调用保存接口。

---

## 推荐实现：完善消息保存逻辑

### 1. 确保后端自动保存消息

根据后端接口需求文档，后端应该在 `createFromNL` 中自动保存消息。前端需要确保：

```typescript
// 在 sendMessage 函数中
const requestData: CreateTripFromNLRequest = {
  text: text.trim(),
  sessionId: sessionId || undefined,  // ✅ 确保传递 sessionId
  clarificationAnswers: Object.entries(questionAnswers).map(([questionId, value]) => ({
    questionId,
    value,
  })),
  // ... 其他字段
};
```

### 2. 更新问题答案（可选）

如果用户回答问题后，需要更新消息的 `questionAnswers`，可以：

**方案A：通过 `updateNLConversation` 更新**
```typescript
// 在用户回答问题后
await tripsApi.updateNLConversation(sessionId, {
  // 后端需要支持更新特定消息的 questionAnswers
  // 或者前端在下次请求时通过 clarificationAnswers 传递
});
```

**方案B：在下次请求时传递答案**
```typescript
// 在 sendMessage 中收集答案
const questionAnswers = collectQuestionAnswers();
const clarificationAnswers = Object.entries(questionAnswers).map(([questionId, value]) => ({
  questionId,
  value,
}));

const requestData: CreateTripFromNLRequest = {
  text: text.trim(),
  sessionId: sessionId || undefined,
  clarificationAnswers,  // ✅ 传递答案
};
```

### 3. 验证消息保存

添加日志验证消息是否正确保存：

```typescript
// 在收到 AI 回复后
if (response.sessionId) {
  // 可选：验证消息是否已保存
  try {
    const conversation = await tripsApi.getNLConversation(response.sessionId);
    console.log('[NLChatInterface] 验证消息保存:', {
      sessionId: conversation.sessionId,
      messageCount: conversation.messages.length,
      lastMessage: conversation.messages[conversation.messages.length - 1],
    });
  } catch (err) {
    console.warn('[NLChatInterface] 验证消息保存失败:', err);
  }
}
```

---

## 代码修改建议

### 1. 确保 sessionId 正确传递

**位置**：`NLChatInterface.tsx` 的 `sendMessage` 函数

**当前代码**：
```typescript
const requestData: CreateTripFromNLRequest = {
  text: text.trim(),
  ...(sessionId && { sessionId }),  // ✅ 已正确传递
  // ...
};
```

**状态**：✅ 已正确实现

### 2. 确保问题答案正确传递

**位置**：`NLChatInterface.tsx` 的 `sendMessage` 函数

**当前代码**：
```typescript
let questionAnswers = providedAnswers || collectQuestionAnswers();

// ... 提取答案逻辑 ...

clarificationAnswers: Object.entries(questionAnswers).map(([questionId, value]) => ({
  questionId,
  value,
})),
```

**状态**：✅ 已正确实现

### 3. 添加消息保存验证（可选）

**位置**：`NLChatInterface.tsx` 的 `sendMessage` 函数，在收到 AI 回复后

**建议添加**：
```typescript
// 在收到 AI 回复后，验证消息是否已保存（仅开发环境）
if (response.sessionId && process.env.NODE_ENV === 'development') {
  setTimeout(async () => {
    try {
      const conversation = await tripsApi.getNLConversation(response.sessionId!);
      const lastUserMessage = conversation.messages.find(m => m.role === 'user');
      const lastAIMessage = conversation.messages.find(m => m.role === 'assistant');
      
      console.log('[NLChatInterface] ✅ 消息保存验证:', {
        sessionId: conversation.sessionId,
        totalMessages: conversation.messages.length,
        lastUserMessage: lastUserMessage?.content.substring(0, 50),
        lastAIMessage: lastAIMessage?.content.substring(0, 50),
      });
    } catch (err) {
      console.warn('[NLChatInterface] ⚠️ 消息保存验证失败:', err);
    }
  }, 1000);  // 延迟1秒，等待后端保存完成
}
```

---

## 后端需要确保的事项

### 1. 自动保存消息

在 `createFromNL` 接口中：

```typescript
// 伪代码
async createFromNL(request: CreateTripFromNLRequest) {
  let conversation: NLConversation;
  
  if (request.sessionId) {
    // 更新现有会话
    conversation = await getConversation(request.sessionId);
    
    // 保存用户消息
    conversation.messages.push({
      id: `user-${Date.now()}`,
      role: 'user',
      content: request.text,
      timestamp: new Date().toISOString(),
      metadata: {}
    });
  } else {
    // 创建新会话
    conversation = await createNewConversation();
    
    // 保存用户消息
    conversation.messages.push({
      id: `user-${Date.now()}`,
      role: 'user',
      content: request.text,
      timestamp: new Date().toISOString(),
      metadata: {}
    });
  }
  
  // ... 处理请求，生成 AI 回复 ...
  
  // 保存 AI 回复消息
  conversation.messages.push({
    id: `ai-${Date.now()}`,
    role: 'assistant',
    content: response.plannerReply || '...',
    timestamp: new Date().toISOString(),
    metadata: {
      suggestedQuestions: response.suggestedQuestions,
      parsedParams: response.partialParams,
      showConfirmCard: !response.needsClarification && response.parsedParams,
      responseBlocks: response.plannerResponseBlocks,
      clarificationQuestions: response.clarificationQuestions,
      questionAnswers: {}  // 初始为空
    }
  });
  
  // 更新会话
  await saveConversation(conversation);
  
  return response;
}
```

### 2. 更新问题答案

**方案A：在下次请求时更新**
- 用户回答问题后，在下次 `createFromNL` 请求中通过 `clarificationAnswers` 传递答案
- 后端更新对应消息的 `metadata.questionAnswers`

**方案B：通过 `updateNLConversation` 更新**
- 前端调用 `PUT /trips/nl-conversation/:sessionId/messages/:messageId`
- 更新特定消息的 `metadata.questionAnswers`

---

## 测试建议

### 1. 测试消息保存

**步骤**：
1. 用户发送第一条消息
2. 检查后端是否创建了新会话
3. 检查会话中是否有用户消息和 AI 回复

**验证**：
```typescript
// 前端验证
const conversation = await tripsApi.getNLConversation(sessionId);
console.assert(conversation.messages.length >= 2, '应该有至少2条消息（用户+AI）');
console.assert(conversation.messages[0].role === 'user', '第一条应该是用户消息');
console.assert(conversation.messages[1].role === 'assistant', '第二条应该是AI回复');
```

### 2. 测试会话恢复

**步骤**：
1. 用户发送几条消息
2. 刷新页面
3. 检查消息是否恢复

**验证**：
```typescript
// 页面加载时
const savedSessionId = localStorage.getItem('nl_conversation_session');
const conversation = await tripsApi.getNLConversation(savedSessionId);
console.assert(conversation.messages.length > 0, '应该恢复消息历史');
```

### 3. 测试问题答案更新

**步骤**：
1. AI 返回澄清问题
2. 用户回答问题
3. 发送下一条消息
4. 检查答案是否正确保存

**验证**：
```typescript
// 检查消息的 questionAnswers
const conversation = await tripsApi.getNLConversation(sessionId);
const aiMessage = conversation.messages.find(m => 
  m.role === 'assistant' && 
  m.metadata?.clarificationQuestions?.length > 0
);
console.assert(
  Object.keys(aiMessage.metadata.questionAnswers || {}).length > 0,
  '应该有保存的答案'
);
```

---

## 总结

### 当前状态

✅ **前端已实现**：
- 会话恢复
- 会话切换
- 更新会话上下文
- 传递 sessionId 和 clarificationAnswers

❌ **需要后端实现**：
- 在 `createFromNL` 中自动保存消息
- 更新消息的 `metadata.questionAnswers`

### 下一步

1. **后端**：实现消息自动保存逻辑（在 `createFromNL` 中）
2. **前端**：添加消息保存验证（可选，用于调试）
3. **测试**：验证消息保存和恢复功能

### 关键点

- ✅ 前端已正确传递 `sessionId` 和 `clarificationAnswers`
- ✅ 前端已实现会话恢复逻辑
- ⚠️ 后端需要确保在 `createFromNL` 中自动保存消息
- ⚠️ 后端需要支持更新消息的 `metadata.questionAnswers`
